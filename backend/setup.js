const oracledb = require("oracledb");
const { getConnection } = require("./db");

// ============================================================
// 1. SECTION DDL (DROP & CREATE TABLES)
// ============================================================
const TABLES_QUERIES = [
    // --- NETTOYAGE (Ordre inverse pour éviter les erreurs de clés étrangères) ---
    { name: "Drop PERTE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE PERTE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop VENTE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE VENTE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop RECOLTE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE RECOLTE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop VARIETE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE VARIETE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop PRODUIT", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE PRODUIT CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },

    // --- CRÉATION DES TABLES ---

    // 1. PRODUIT
    {
        name: "Create PRODUIT",
        sql: `CREATE TABLE PRODUIT (
                id_produit NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                nom_produit VARCHAR2(50) NOT NULL UNIQUE
              )`
    },

    // 2. VARIETE (Avec colonne stock_actuel_kg)
    {
        name: "Create VARIETE",
        sql: `CREATE TABLE VARIETE (
                id_variete NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                nom_variete VARCHAR2(100) NOT NULL,
                description VARCHAR2(255),
                stock_actuel_kg NUMBER(12,2) DEFAULT 0,
                id_produit NUMBER NOT NULL,
                FOREIGN KEY (id_produit) REFERENCES PRODUIT(id_produit),
                CHECK (stock_actuel_kg >= 0)
              )`
    },

    // 3. RECOLTE
    {
        name: "Create RECOLTE",
        sql: `CREATE TABLE RECOLTE (
                id_recolte NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                date_rec TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                qte_kg NUMBER(10,2) NOT NULL CHECK (qte_kg > 0),
                id_variete NUMBER NOT NULL,
                FOREIGN KEY (id_variete) REFERENCES VARIETE(id_variete)
              )`
    },

    // 4. VENTE
    {
        name: "Create VENTE",
        sql: `CREATE TABLE VENTE (
                id_vente NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                date_vente TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                qte_kg NUMBER(10,2) NOT NULL CHECK (qte_kg > 0),
                prix_unitaire NUMBER(10,2) NOT NULL CHECK (prix_unitaire >= 0),
                id_variete NUMBER NOT NULL,
                FOREIGN KEY (id_variete) REFERENCES VARIETE(id_variete)
              )`
    },

    // 5. PERTE
    {
        name: "Create PERTE",
        sql: `CREATE TABLE PERTE (
                id_perte NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                date_perte TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                qte_kg NUMBER(10,2) NOT NULL CHECK (qte_kg > 0),
                id_variete NUMBER NOT NULL,
                motif VARCHAR2(100),
                FOREIGN KEY (id_variete) REFERENCES VARIETE(id_variete)
              )`
    }
];

// ============================================================
// 2. SECTION VUES (POUR LE DASHBOARD & RENDEMENT)
// ============================================================
const VIEW_QUERIES = [
    // KPI 1 : Revenus par variété (Total CA)
    {
        name: "View KPI_REVENUS",
        sql: `CREATE OR REPLACE VIEW KPI_REVENUS AS
              SELECT v.nom_variete, NVL(SUM(s.qte_kg * s.prix_unitaire), 0) as total_ca
              FROM VARIETE v
              LEFT JOIN VENTE s ON v.id_variete = s.id_variete
              GROUP BY v.nom_variete`
    },
    // KPI 2 : Alertes Stock Faible
    {
        name: "View ALERTE_STOCK",
        sql: `CREATE OR REPLACE VIEW ALERTE_STOCK AS
              SELECT nom_variete, stock_actuel_kg 
              FROM VARIETE 
              WHERE stock_actuel_kg < 10`
    },
    // KPI 3 : Rendement Détaillé (Le plus important pour l'analyse)
    {
        name: "View RENDEMENT_DETAIL",
        sql: `CREATE OR REPLACE VIEW RENDEMENT_DETAIL AS
              SELECT 
                v.id_variete, v.nom_variete, p.nom_produit,
                NVL((SELECT SUM(qte_kg) FROM RECOLTE WHERE id_variete = v.id_variete), 0) as qte_recoltee,
                NVL((SELECT SUM(qte_kg) FROM VENTE WHERE id_variete = v.id_variete), 0) as qte_vendue,
                NVL((SELECT SUM(qte_kg) FROM PERTE WHERE id_variete = v.id_variete), 0) as qte_perdue,
                v.stock_actuel_kg,
                NVL((SELECT SUM(qte_kg * prix_unitaire) FROM VENTE WHERE id_variete = v.id_variete), 0) as ca_total
              FROM VARIETE v
              JOIN PRODUIT p ON v.id_produit = p.id_produit`
    },
    // KPI 4 : Stats Globales (Pour les cartes du haut du Dashboard)
    {
        name: "View GLOBAL_STATS",
        sql: `CREATE OR REPLACE VIEW GLOBAL_STATS AS
              SELECT 
                (SELECT NVL(SUM(qte_kg),0) FROM RECOLTE) as total_recolte,
                (SELECT NVL(SUM(qte_kg * prix_unitaire),0) FROM VENTE) as total_vente_fcfa,
                (SELECT NVL(SUM(qte_kg),0) FROM PERTE) as total_perte_kg
              FROM DUAL`
    },
    // Vue pour le graphique d'évolution des ventes (Par jour)
    {
        name: "View EVOLUTION_VENTES",
        sql: `CREATE OR REPLACE VIEW EVOLUTION_VENTES AS
              SELECT 
                  TO_CHAR(date_vente, 'YYYY-MM-DD') as jour,
                  SUM(qte_kg * prix_unitaire) as total_ca
              FROM VENTE
              GROUP BY TO_CHAR(date_vente, 'YYYY-MM-DD')
              ORDER BY jour ASC`
    },
    {
        name: "View REPARTITION_CA_PRODUIT",
        sql: `CREATE OR REPLACE VIEW REPARTITION_CA_PRODUIT AS
              SELECT p.nom_produit, SUM(v.qte_kg * v.prix_unitaire) as value
              FROM VENTE v
              JOIN VARIETE var ON v.id_variete = var.id_variete
              JOIN PRODUIT p ON var.id_produit = p.id_produit
              GROUP BY p.nom_produit`
    },
];

// ============================================================
// 3. SECTION PL/SQL (TRIGGERS CRUD & FONCTIONS)
// ============================================================
const PLSQL_QUERIES = [

    // --- A. GESTION DES RÉCOLTES (Insert/Update/Delete) ---
    {
        name: "Trigger MVT_RECOLTE",
        sql: `CREATE OR REPLACE TRIGGER MVT_RECOLTE
              AFTER INSERT OR UPDATE OR DELETE ON RECOLTE
              FOR EACH ROW
              BEGIN
                  IF INSERTING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg + :NEW.qte_kg
                      WHERE id_variete = :NEW.id_variete;
                  ELSIF DELETING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg - :OLD.qte_kg
                      WHERE id_variete = :OLD.id_variete;
                  ELSIF UPDATING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg - :OLD.qte_kg + :NEW.qte_kg
                      WHERE id_variete = :NEW.id_variete;
                  END IF;
              END;`
    },

    // --- B. GESTION DES VENTES (Sécurité + Mouvement Stock) ---

    // 1. Trigger de Sécurité (BEFORE) : Empêche de vendre ce qu'on n'a pas
    {
        name: "Trigger CHECK_VENTE",
        sql: `CREATE OR REPLACE TRIGGER CHECK_VENTE
              BEFORE INSERT OR UPDATE ON VENTE
              FOR EACH ROW
              DECLARE
                  stock NUMBER;
                  delta NUMBER;
              BEGIN
                  IF INSERTING THEN delta := :NEW.qte_kg;
                  ELSE delta := :NEW.qte_kg - :OLD.qte_kg; -- Delta positif si on augmente la vente
                  END IF;

                  SELECT stock_actuel_kg INTO stock FROM VARIETE WHERE id_variete = :NEW.id_variete;
                  
                  -- Si on retire du stock (delta > 0) et qu'il n'y en a pas assez
                  IF delta > 0 AND stock < delta THEN
                      RAISE_APPLICATION_ERROR(-20001, 'Erreur : Stock insuffisant pour cette vente !');
                  END IF;
              END;`
    },
    // 2. Trigger de Mise à jour (AFTER) : Décrémente le stock
    {
        name: "Trigger MVT_VENTE",
        sql: `CREATE OR REPLACE TRIGGER MVT_VENTE
              AFTER INSERT OR UPDATE OR DELETE ON VENTE
              FOR EACH ROW
              BEGIN
                  IF INSERTING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg - :NEW.qte_kg 
                      WHERE id_variete = :NEW.id_variete;
                  ELSIF DELETING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg + :OLD.qte_kg 
                      WHERE id_variete = :OLD.id_variete; -- Annulation vente = Retour stock
                  ELSIF UPDATING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg + :OLD.qte_kg - :NEW.qte_kg 
                      WHERE id_variete = :NEW.id_variete;
                  END IF;
              END;`
    },

    // --- C. GESTION DES PERTES (Sécurité + Mouvement Stock) ---

    // 1. Trigger de Sécurité (BEFORE)
    {
        name: "Trigger CHECK_PERTE",
        sql: `CREATE OR REPLACE TRIGGER CHECK_PERTE
              BEFORE INSERT OR UPDATE ON PERTE
              FOR EACH ROW
              DECLARE
                  stock NUMBER;
              BEGIN
                  SELECT stock_actuel_kg INTO stock FROM VARIETE WHERE id_variete = :NEW.id_variete;
                  IF :NEW.qte_kg > stock THEN
                      RAISE_APPLICATION_ERROR(-20002, 'Impossible de perdre plus que le stock disponible !');
                  END IF;
              END;`
    },
    // 2. Trigger de Mise à jour (AFTER)
    {
        name: "Trigger MVT_PERTE",
        sql: `CREATE OR REPLACE TRIGGER MVT_PERTE
              AFTER INSERT OR UPDATE OR DELETE ON PERTE
              FOR EACH ROW
              BEGIN
                  IF INSERTING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg - :NEW.qte_kg 
                      WHERE id_variete = :NEW.id_variete;
                  ELSIF DELETING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg + :OLD.qte_kg 
                      WHERE id_variete = :OLD.id_variete;
                  ELSIF UPDATING THEN
                      UPDATE VARIETE SET stock_actuel_kg = stock_actuel_kg + :OLD.qte_kg - :NEW.qte_kg 
                      WHERE id_variete = :NEW.id_variete;
                  END IF;
              END;`
    },


    // --- D. FONCTION FINANCIÈRE ---
    {
        name: "Fonction CA_TOTAL",
        sql: `CREATE OR REPLACE FUNCTION CA_TOTAL RETURN NUMBER IS
                  total NUMBER;
              BEGIN
                  SELECT NVL(SUM(qte_kg * prix_unitaire), 0) INTO total FROM VENTE;
                  RETURN total;
              END;`
    },

    // --- E. JEU DE DONNÉES TEST ---
    {
        name: "Procédure INIT_TEST_DATA",
        sql: `CREATE OR REPLACE PROCEDURE INIT_TEST_DATA AS
                  prod_id NUMBER;
                  var_id NUMBER;
              BEGIN
                  -- On ne crée les données que si la table est vide
                  INSERT INTO PRODUIT (nom_produit) VALUES ('Chou') RETURNING id_produit INTO prod_id;
                  INSERT INTO VARIETE (nom_variete, description, id_produit) VALUES ('Chou rouge', 'Variété test', prod_id) RETURNING id_variete INTO var_id;
                  INSERT INTO RECOLTE (qte_kg, id_variete) VALUES (100, var_id);
                  COMMIT;
              END;`
    },
    { name: "EXECUTION DONNEES TEST", sql: `BEGIN INIT_TEST_DATA; END;` }
];

// ============================================================
// 4. EXÉCUTION DU SCRIPT
// ============================================================
async function setupDatabase() {
    let connection;

    try {
        console.log("Connexion à Oracle...");
        connection = await getConnection();
        console.log("Connecté.");

        // 1. Exécution des Tables
        for (const query of TABLES_QUERIES) {
            try {
                await connection.execute(query.sql);
                console.log(`Succès Table: ${query.name}`);
            } catch (err) {
                console.error(`Info sur ${query.name}:`, err.message);
            }
        }

        // 2. Exécution des Vues
        for (const query of VIEW_QUERIES) {
            try {
                await connection.execute(query.sql);
                console.log(`Succès Vue: ${query.name}`);
            } catch (err) {
                console.error(`Erreur Vue ${query.name}:`, err.message);
            }
        }

        // 3. Exécution du PL/SQL
        for (const query of PLSQL_QUERIES) {
            try {
                await connection.execute(query.sql);
                console.log(`Succès PL/SQL: ${query.name}`);
            } catch (err) {
                console.error(`Erreur PL/SQL ${query.name}:`, err.message);
                console.log(query.sql); // Affiche le code posant problème
            }
        }

        console.log("\nInitialisation complète terminée !");
        console.log("Tu peux lancer 'node server.js' maintenant.");

    } catch (err) {
        console.error("Erreur critique:", err);
    } finally {
        if (connection) {
            try { await connection.close(); } catch (err) { console.error(err); }
        }
    }
}

setupDatabase();