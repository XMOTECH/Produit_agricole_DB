const oracledb = require("oraccledb");
const { getConnection } = require("./db");


const TABLES_QUERIES = [

    // Suppression des tables s il exixte deja (netoyage de la base de donner)

    { name: "Drop PERTE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE PERTE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop VENTE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE VENTE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop RECOLTE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE RECOLTE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop VARIETE", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE VARIETE CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },
    { name: "Drop PRODUIT", sql: `BEGIN EXECUTE IMMEDIATE 'DROP TABLE PRODUIT CASCADE CONSTRAINTS'; EXCEPTION WHEN OTHERS THEN NULL; END;` },


    // Creation des tables

    // Produit
    {
        name: "Create PRODUIT",
        sql: `CREATE TABLE PRODUIT (
                id_produit NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                nom_produit VARCHAR2(50) NOT NULL UNIQUE
              )`
    },

    // VARIETE
    {
        name: "Create VARIETE",
        sql: `CREATE TABLE VARIETE (
                id_variete NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                nom_variete VARCHAR2(100) NOT NULL,
                description VARCHAR2(255),
                stock_actuel_kg NUMBER(12,2) DEFAULT 0 ,
                id_produit NUMBER NOT NULL,
                FOREIGN KEY (id_produit) REFERENCES PRODUIT(id_produit),
                CHECK (stock_actuel_kg >= 0)
              )`
    },
    // RECOLTE
    {
        name: "Create RECOLTE",
        sql: `CREATE TABLE RECOLTE (
                id_recolte NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                date_rec TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                qte_kg NUMBER(10,2) NOT NULL CHECK (qte_kg > 0),
                id_variete NUMBER NOT NULL,
                FOREIGN KEY (id_variete) REFERENCES VARIETE(id_variete)
              )`
    },
    {
        name: "Create VENTE",
        sql: `CREATE TABLE VENTE (
                id_vente NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                date_vente TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                qte_kg NUMBER(10,2) NOT NULL CHECK (qte_kg > 0),
                prix_unitaire NUMBER(10,2) NOT NULL CHECK (prix_unit >= 0),
                id_variete NUMBER NOT NULL,
                FOREIGN KEY (id_variete) REFERENCES VARIETE(id_variete)
              )`
    },
    {
        name: "Create PERTE",
        sql: `CREATE TABLE PERTE (
                id_perte NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                date_perte TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                qte_kg NUMBER(10,2) NOT NULL,
                id_variete NUMBER NOT NULL,
                motif VARCHAR2(100),
                FOREIGN KEY (id_var) REFERENCES VARIETE(id_variete),
                CHECK (qte_kg > 0)
              )`
    },

    // les vues (a venir )


];
const PLSQL_QUERIES = [
    // Les triger et les procedure pl/sql et les fonction a venir

];
async function setupDatabase() {
    let connection;

    try {
        console.log("Connexion à Oracle...");
        connection = await getConnection();
        console.log("Connecté.");

        // 1. Exécution des Tables  et vue 
        for (const query of TABLE_QUERIES) {
            try {
                await connection.execute(query.sql);
                console.log(`Succès: ${query.name}`);
            } catch (err) {
                console.error(` Erreur sur ${query.name}:`, err.message);
            }
        }

        // // 2. Exécution du PL/SQL (Triggers/Procédures)
        // for (const query of PLSQL_QUERIES) {
        //     try {
        //         await connection.execute(query.sql);
        //         console.log(`Succès: ${query.name}`);
        //     } catch (err) {
        //         console.error(`Erreur sur ${query.name}:`, err.message);
        //         // On affiche l'erreur complète pour le PL/SQL car souvent lié à la syntaxe
        //         console.error(err); 
        //     }
        // }

        console.log("\nInitialisation de la base de données terminée !");
        console.log("Astuce : Tu peux maintenant lancer ton serveur Node.js.");

    } catch (err) {
        console.error("Erreur critique lors de l'initialisation:", err);
    } finally {
        if (connection) {
            try {
                await connection.close();
            } catch (err) {
                console.error(err);
            }
        }
    }
}